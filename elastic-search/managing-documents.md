# Managing Documents

### Creating An Index With Default Options
```bash
PUT /<index_name>
```
### Creating An Index With Custom Options
```bash
PUT /<index_name>
{
  "settings": {
    "number_of_replicas": 2,
    "number_of_shards": 2
  }
}
```
#### Create Index Response (Success)
```json
{
  "acknowledged": true,
  "shards_acknowledged": true,
  "index": "<index_name>"
}
```

#### :warning: Elastic search will throw an error when trying create an index which already exists.

### Deleting An Index
```bash
DELETE /<index_name>
```
#### Response (Success)
```json
{
  "acknowledged": true
}
```
#### :warning: Elasticsearch will throw an error when trying to delete an index that doesn't exist.

### Indexing/Adding A Document
```bash
POST /<index_name>/_doc
{
  "name":"Red Marker",
  "price":250.75,
  "aval_qty":250,
  "attrs":{
    "color":"red",
    "brand":"Camel",
    "size":"L"
  }
}
```
#### Response (Success)
```json
{
  "_index": "products",
  "_id": "sDqUYoIBeKcjnN9MdCUx",
  "_version": 1,
  "result": "created",
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  },
  "_seq_no": 0,
  "_primary_term": 1
}
```
### :information_source:
- Every document will have an `_id` property. If not specified an automatic value will be generated by the ES.
- These is a setting `action.auto_create_index`, if set then an index will be created if it doesn't exist while trying to add the document.
- The `_shards` property contains to how many shards the document has been written and replicated.

### Getting A Document By ID
```bash
GET /<index_name>/_doc/<id>
```
#### Response (Success)
```json
{
  "_index": "products",
  "_id": "sDqUYoIBeKcjnN9MdCUx",
  "_version": 1,
  "_seq_no": 0,
  "_primary_term": 1,
  "found": true,
  "_source": {
    "name": "Red Marker",
    "price": 250.75,
    "aval_qty": 250,
    "attrs": {
      "color": "red",
      "brand": "Camel",
      "size": "L"
    }
  }
}
```
#### Response (Not Found):
```json
{
  "_index": "products",
  "_id": "sDqUYoIBeKcjnN9MdCUx1",
  "found": false
}
```
### :information_source:
- The response contains additional meta information apart from the document data.
- The actual document will be inside the `_source` property.
- The found property will indicate if a document is found by the id we are trying to fetch with. True if found false otherwise.

### Updating A Document By ID
```bash
POST /<index_name>/_update/<_id>
{
  "doc":{
    "aval_qty":300,
    "discount":0.0
  }
}
```
#### Response:
```json
{
  "_index": "products",
  "_id": "sDqUYoIBeKcjnN9MdCUx",
  "_version": 2,
  "result": "updated",
  "_shards": {
    "total": 2,
    "successful": 1,
    "failed": 0
  },
  "_seq_no": 1,
  "_primary_term": 1
}
```
### :information_source:
- ES documents are immutable. So how the update is working? ES is not actually updaing the existing document but replacing it with the same `_id`. First the ES will fetch the document into memory and apply the updates and replaces the current one with the updated doc in memory keeping the same `_id`.
- the `result` property from the response informs what operation has happened. **updated**: means the document updated, **noop**: no operation performed.

### Scripted Updates
Sometimes we want to update the document when certain conditions are met, or in other case we want to update the document with reading it first.
```bash
POST /<index_name>/_update/<_id>
{
  "script": {
    "source": """
      if(ctx._source.aval_qty < 500 ){
        ctx._source.aval_qty += params.add_qty    
      }
    """,
    "params": {
      "add_qty":100
    }
  }
}
```
In the above example we are checking if the available quantity of the product is less than 500, then add additional quantity of 100 to the what ever the value of avilable quantity property. the `ctx` represents the current document in the context.

### Upserts
If ES didn't find a document with the given ID then a new document will be created.
```bash
POST /<index_name>/_update/<_id>
{
  "script": {
    "source": """
      if(ctx._source.aval_qty < 500 ){
        ctx._source.aval_qty += params.add_qty    
      }
    """,
    "params": {
      "add_qty":100
    }
  },
  "upsert": {
    "name":"Blue Marker",
    "price":300,
    "aval_qty":150,
    "attrs":{
      "color":"Blue",
      "brand":"Camel",
      "size":"L"
    }
  }
}
```
If the ES found a document with the given id then the `script` will be executed the result will be `updated`. If a document is not found with the given id then the `upsert` property will be executed and a new document will be indexed. and the result will be `created`.

### Replacing Documents
All the previous data of the document will be replaced by the current data.
```bash
POST /<index_name>/_doc/<_id>
{
  "name":"Red Marker",
  "price":250.75,
  "aval_qty":250,
  "attrs":{
    "color":"red",
    "brand":"Camel",
    "size":"L"
  }
}
```
### Deleting A Document
```bash
DELETE /<index_name/_doc/<_id>
```

## Routing
The process of resolving a shard for a document is called routing.
```
shard_num = hash(_routing) % num_primary_shards
```
This is the routing formula ES uses to determine to/from which shard the document to be stored/read. As this formula depends on the number of shards, it is not allowed to change the number of shards for a given index once it is created as by changing the number of shards it will become difficult to search existing documents. By default ES uses the `_id` as the `_routing`. We can change the routing function but we have to make sure that the function we are writing is distributing documents evenly over all the shards.

## How ES Reads Documents
1. First a coordinator node receives the read request.
2. Then the coordinator node uses routing function to figure out the replication group to look up.
3. ES uses ARS(Adaptive Replica Selection) technique to figure out which shard is best suited for serving the current read request.
4. Once the coordinating node get to know which shard, then the coordinating note reads the document from the shard and returns it to the client.

## How ES Writes Documents
1. Coordinator node receives the write request.
2. Uses routing to determine the replication group.
3. Sends the write request to the primary shard in the replication group which will validate the request and writes the request locally before parallelly writing request to the other replica shards in the replication group. Operation will be success even when the write operation to replica shards failed.

### Handling Failures At Write Time
Each replica groups needs a primary shard at all times.

**Example for a failure scenario**
```
A replication group called A which is composed of one primary shard and two replica shards. Now a documented got indexed locally in primary shard and written to one of the replication shard. But the primary shard went down due to some infrastrcuture issue and the document didn't get write to the second shard.
```
Now when the primary shard went down, one of the remaining replica shards made primary shard. Every document has one property called `_primary_term` which indicates the shard that is acting as primary shard during operation of the document. When there was a change in the primary shard then ES upddates the `_primary_term` for the replication group. Also every document has `_seq_no` property whihc is like a counter indicating the sequence number for the write operation of the document. Also there are global check points common for replication group, local checkpoints for each shard. Using all these the shards will keep the data in sync within the replication group.

For example if the global checkpoint(sequence number) for a replication group is 100 then all the local checkpoints should be atleast 100. If the local checkpoint of shard B is 150 and checkpoint of C is 100 which is acting as primary shard then the Shard C will sync all the documents with suequence number greater than 100 till 150 to be in sync with Shard B which is acting as replica.

## Document Versioning (Legacy)
Document versioning is used to determine how many times a document is updated. There are two types of versioning available. internal and external. In the internal versioning only the version number will be stored but not the actual document history. But in case of external versioning ES stores history of the document with specified version number which will be a natural number.

## Optimistic Concurrency Control
This process is used to prevent old data replacing new data. or handle issues with concurrent read, write operations. In the legacy ES `_version` is being used. But now ES uses `_primary_term` and `_seq_no` properties.
```bash
POST /<index_name>/_update/1?if_primary_term=1&if_seq_no=6
{
  "doc": {
    "aval_qty":140
  }
}
```
If we face an error about version conflict we have to read the document again and use the latest `_primary_term` and `_seq_no`.



